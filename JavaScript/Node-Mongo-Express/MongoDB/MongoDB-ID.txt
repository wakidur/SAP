https://stackoverflow.com/questions/25356211/collection-id-length-in-mongodb

Collection ID length in MongoDB


Why is the default _id a 24 character hex string?
The default unique identifier generated as the primary key (_id) for a MongoDB document is an ObjectId. This is a 12 byte binary value which is often represented as a 24 character hex string, and one of the standard field types supported by the MongoDB BSON specification.

The 12 bytes of an ObjectId are constructed using:

a 4 byte value representing the seconds since the Unix epoch
a 3 byte machine identifier
a 2 byte process id
a 3 byte counter (starting with a random value)

What is the importance of an ObjectId?
ObjectIds (or similar identifiers generated according to a GUID formula) allow unique identifiers to be independently generated in a distributed system.

The ability to independently generate a unique ID becomes very important as you scale up to multiple application servers (or perhaps multiple database nodes in a sharded cluster). You do not want to have a central coordination bottleneck like a sequence counter (eg. as you might have for an auto-incrementing primary key), and you will want to insert new documents without risk that a new identifier will turn out to be a duplicate.

An ObjectId is typically generated by your MongoDB client driver, but can also be generated on the MongoDB server if your client driver or application code or haven't already added an _id field.

Do I have to use the default ObjectId?
No. If you have a more suitable unique identifier to use, you can always provide your own value for _id. This can either be a single value or a composite value using multiple fields.

The main constraints on _id values are that they have to be unique for a collection and you cannot update or remove the _id for an existing document.


@KennyWorden ObjectIds currently use a signed 32-bit int (i.e. unixtime), so you're correct that the time component will roll over eventually (see also: What will happen to ObjectIDs in year 2038?). Generated ObjectIds should continue be unique (byte wise) for a while after rollover but certain assumptions (such as ordering by a monotonically increasing time prefix) would no longer hold true. I assume there will be a replacement ObjectId subtype introduced before then :). – Stennie Jul 13 '15 at 5:47
I believe the unixtime component was originally included for uniqueness and a rough ordering of generated ObjectIds, and not to embed a timestamp in default _ids (although certainly developers have made assumptions about the timestamp aspect since then). There have been several ObjectId variations already, as implemented by different legacy drivers (see the "subtypes" in the BSON spec or as written up in UUID Support in Robomongo). – Stennie Jul 13 '15 at 5:51 
1
SIGNED? Why? They don't need to track time before the epoch! – Kenny Worden Jul 13 '15 at 6:36
@KennyWorden See also: unix time: "Unix time is a single signed integer number which increments every second". I presume that "seemed like a good idea at the time" to the Unix kernel devs (similar to the choice of 1-Jan-1970 as the unix epoch). The usage in ObjectId generation is following the established convention for convenience. The overall ObjectId wants to be uniquely generated, but as noted I don't think it necessarily has to embed a timestamp. You're also free to use your own unique identifiers for _id rather than the default ObjectId. – Stennie Jul 13 '15 at 6:47
Thanks for your answers! I'll definitely look into this some more. :) – Kenny Worden Jul 13 '15 at 6:49

---------------------------------------------------------------------------------------------------------
Important considerations for MongoDB
1) Turn journaling on by default.
2) Your working set should fit in memory.
3) Take care the location of your data files.
4) Keep yourself updated with stable versions.
5) Use Mongo MMS to graphically monitor your service.
6) Scale up if your metrics show heavy use.
7) Use sharding if data size is huge but be careful.
8) Use an application driver maintained by the MongoDB team.
9) Schedule regular automated backups, manual backups should be avoided.
10) Enable database access control.
11) Test your deployment using real data.

