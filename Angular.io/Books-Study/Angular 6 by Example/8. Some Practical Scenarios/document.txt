footprint(পদচিহ্ন, )
tweak(খামচি, খামচি মারা)
trick(কৌশল, চাল)
impressive (গভীর, হৃদয়গ্রাহী)
drastically(আয়তন বহুলাংশে)
substantially(যথেষ্ট)
nifty (ছিমছাম)
quirky(বিচিত্র)
compilation(সংকলন)
compile(সঙ্কলন করা, রচনা করা)
full-fledged (পূর্ণবর্ধিত, পরিপক্ব, পরিণত, পাকা,)
pronounced(উচ্চারিত)
re-rendering (পুনরায় রেন্ডারিং)
evolves(উন্নতির)
tied (বাঁধা)
against(বিরুদ্ধে)
reside(বাস করা)
abstraction (অন্যমনস্ক অবস্থা, অপসারণ)
perceived (অনুভূত,উপলব্ধ)
tout(দালালি করা)
touted(দালালি)
Offloading (অফলোড)
neat(পরিচ্ছন্ন)
mainstream(মূলধারার,প্রধান ধারা )
alleviate (উপশম করা, কমানো)
norm(আদর্শ)
impose (আরোপ করা, )
avenues(রাজপথ)
superb (চমত্কার, অতীব কার্যকর)
roughly (মোটামুটিভাবে)
/*
    *03-12-2018
*/

8. Some Practical Scenarios
    8.1. Building a new app
        8.1.1. Seed projects
    8.2. Angular performance
        Every part of the framework, 
            Starting from the framework footprint, 
            Initial load time,
            memory utilization,
            Change detection plus data binding
            DOM rendering,
/*
    * 04-12-2018
*/
        8.2.1. Byte size
            The standard techniques of 
                Minification 
                gzipping 
                can reduce the gap substantially 
            
            Tree shaking : Tree Shaking can result in enormous size reduction as you don't bundle framework bit that you don't use

            Using tree shaking together with Ahead-of-Time (AoT) compilation, we can just get rid of the Angular compiler (in the browser) altogether.

            With AoT compilation, the view template(HTML) are compiled beforehand on the server side. This compilation again is done as part of the app's build process where a server version fo the Angular compiler compiles every view in the application.

            With all the templates compiled, there is no need to send the Angular compiler bits to the client side at all. Tree Shaking can now just get rid of the compiler and create a far slimmer framework package.

        8.2.2. Initial load time and memory utilization
        8.2.3. The Angular rendering engine
            The biggest disadvantage of the AngularJS was that the framework was tied to the browser DOM.
            The Directive, the binding, and the interpolatins all worked against the DOM.

            With Angular , the biggest architectural change that came in was a separte rendering layer. 
            Now, an Angular app has two larys 

                Application layer: This is the layer out code resides in. It uses an abstraction build over the renderer layer to interact with it. 

                Rendering larys:  This layer is responsible for translating requests from the application layer into rendered components, and reacting to user input and view updates.
        
        8.2.4. Server-side rendering
            Pre-rendering 
            In such a scenario, when the user requests for a view/page, a piece of software on the server generates a fully materialized HTML page with data pre-bound to the view and sends it to the client along with a small script. The app view is therefore immediately rendered, ready for interaction. While the framework loads in the background, the small script that was sent along the first time captures all user inputs and makes them available to the framework, allowing it to replay the interactions once it is loaded.

            Angular Universal, as it is touted, allows rendering and sharing of the view both on the server and the client side.

            Server-side rendering is only made possible because of separation of the rendering layer described previously. The initial view is generated by a renderer implementation on the server, named ServerDomRenderer. There is a Node.js plugin (http://bit.ly/ng-universal-node) that can be used in a number of node web frameworks such as Express, Hapi, Sail, and others.

            Performance is not the only benefit with server-side rendering. As it turns out, search indexers too like pre-rendered HTML content. Server-side rendering is really useful in areas such as search engine optimization (SEO) and deep linking, which allows easy content sharing.
        
        8.2.5. Offloading work to a web worker
             
            In today's world, CPUs with multiple cores are the norm, but JavaScript execution is still single-threaded. There is a need for a standard/mechanism to utilize these idle cores for our apps. Web workers fit the bill perfectly, and since most modern browsers support them, we all should be writing code that utilizes web workers.
        
        8.2.6. Performant mobile experience
        8.2.7. Change detection improvements
            8.2.7.1. Change detection
                Angular's data binding engine does a great job of binding the view with the model data (component data). These are live bindings where Angular keeps the view in sync with model changes. Any time the model changes, the binding engine re-renders parts of the view that are dependent on the model. To manage this view-model synchronization, Angular needs to know when the model changed and what changed exactly. This is what change detection is all about. During app execution, Angular frequently does what we call change detection runs to determine what changed.

                If you are from AngularJS, a change detection run is roughly equivalent to digest cycles, except that in Angular there are no cycles

                While this problem of keeping the model and view in sync may sound simple, it's a tough nut to creck. Unlike the component tree, the interconnection between multiple models can be complex. 
                Changes in one componet model can trigger changes in muluple component models. 
                Furthermore, these interconnection may have cycles. A single model property could be bound to multiple views. All thes complex scenarios need to be managed using  a robust change detection infrastructure.

            8.2.7.2. Change detection setup 


            






