// 14-08-2018 -------------------------------
neat (খাঁটি, পরিচ্ছন্ন )
relies(নির্ভর করা, বিশ্বাস করা)
poses(অঙ্গভঙ্গি)
credentials(পরিচয়পত্র)
aspect( দৃষ্টিভঙ্গি, দৃশ্য, চেহারা, মুখাকৃতি, মুখাবয়ব, গ্রহদৃষ্টি )
spot(স্থাননির্ণয় করা)
dramatically(নাটকীয়ভাবে)
weakens(দুর্বল হয়ে পড়ে)
strength(শক্তি)
strategy(কৌশল)
11 Authenticating users, managing sessions, and securing APIs
    11.1 How to approach authentication in the MEAN stack
        11.1.1 Traditional server-based application approach

            In a traditional setup, the application code sits and runs on the server. For users to log in they enter their username and Password into a form that gets posted to the server. The server then checks against a database to validate the login details. 
            Assuming the login is okay, 
            The server will set a flag or session parameter in users, session on the server to declare that they'r logged in. (সার্ভার ব্যবহারকারীর সেশনে একটি পতাকা বা সেশনের প্যারামিটার সেট করবে যাতে তারা লগ ইন করে বলে ঘোষণা করে।)

            The server may or may not set a cookie on users browsers with the session information.
            This is quite common, but isn't technically required to manage the authenticated session-it's server that maintains the vital session information, 

            When users then request a secure resource or try to submit some data to the database it's the server that validates their session and whether or not it can continue.

            Using the traditional approach in the MEAN stack

                Express do not maintain sessions for each user the entire application for all users runs on a single thread.

                That said, a traditional version of the approach can be used in the MEAN stack if you're using a server-side application based on Express.

                Rather than using server resources to maintain session information, Express can use a database to store the data. MongoDB can be used; another popular option for this is Redis, which is a lightning-fast key-value store.

        11.1.2 Full MEAN stack approach
            Authentication in the MEAN stack poses two problemes.
            1. The API is stateless as Express and Node have no concept of user session. 
            2. The application logic is already delivered to the browser, so you can't limit the code that gets delivered. 

            The logical solution to these problems is to maintain some kind of session state in the browser, and let the application decide what it can and cannot desplay to the current user. This is the only fundamental change in approach. There are a few technical differences, but this is the only major shift.

            A great way to securely keep user data in the browser in order to maintain a session is to use a JSON Web Token (JWT).

            Managin the login process
                Users post their credentials to the server (vie an API) the server validates these using the database, and returns a token to the browser. The browser will save this token to reuse it later. This is vary similar to the traditional approach, but instead of storing each user's session data on the server, it's stored in the browser. 
// 15-08-2018------------------------            
            Changing views during an authenticated session
                While users are in a session, they will need to be able to change a page or view, and the application will need to know what they should be allowed to see. The application will decode the JWT and use the information to show the appropriate data to users.
                This is where the change from the traditional application is really obvious. The server is completely unaware that users are doing anything, until they need to access the API and database. 

// 16-08-2018------------------------  
            Securely calling an API 

    11.2 Creating a user schema for MongoDB        
        11.2.1 One-way password encryption: Hashes and salts
            The thing to do here is run a one-way encryption on the password. One-way encryption prevents anything from decrypting the password, while still making it quite easy to validate a correct password. When users try to log in the application can encrypt a given password and see it it matches to stored value.

            Just encrypting isn't quite enough. If several people used the word "password" as their password (it happens!) then the encryption for each will be the same. Any hackers looking through the database could see this pattern and identity poteentially weak password.

            This is where the concept of a "salt" comes in. A "salt" is a random string generated by the application for each user that's combined with the password befor encryption.
            The resulting encrypted value is called the hash, 
            A hash is creatd by combining user's password with random "salt" and encrypting them.


// 18-08-2018 ------------------------
        11.2.2 Building the Mongoose schema
            Basic user schema.
        
        11.2.3 Setting encrypted paths using Mongoose methods
            Adding a Method to a Mongoose schema;
                Fortunately, there’s a native Node module for that: crypto.
            
            Using the crypto module for encryption
                Encryption is such a common requirement there’s a module built into Node Called "crypto". It comes with several methods for managing the encryption of data; we'll look at the following two 

                A. randomBytes - To generate a cryptographically strong string of data to use as the salt.

                B. pbkdf2Sync - To create the hash form the password and the salt; pbkdf2 stands for "password-based key derivation function 2" and industry standard.

                We'ra going touse these methods to create a random string for the salt, and for encrypting the password and salt into the hash. 
                
                ** This first stap is to require crypto in the top of the file.
                ** Second, we'll update the setPassword method to set the salt and the hash for users.
                To ste the salt we'll use the "randomBytes" method to generate a random 16-byte string. 
                Then we'll use the pbkdf2Sync method to create the encrypted hash form the password and the salt. 

            11.2.4 Validating a submitted password
                The other aspect of storing a password is being able to retrieve it when users try to log in -- we need to be able to validate their credentials. Having encrypted the password we can't decrypt it, so what we need to do is use the same encryption on the password the user is trying to log in with, and see if it matches the stored value.
                
            11.2.5 Generating a JSON Web Token
// 19-08-2018 -----------------------------------

// 28-08-2018 -----------------------------------
                A JWT is used to pass data around, in our case between the API on the server and the SPA in the browser, A JWT can also be used by the server that generate the token to authenticate a user, when it's returned in a subsequent request.

                Three parts of JWT
                    Header -- An encoded JSON object containing the type and the hashing algorithm used.

                    Payload -- An encoded JSON object containing the data, the real body of the token 

                    Signature -- An encrypted hash of the header and payload, using a "secret" that only the originating server knows.

                    atob() ------ decode a Base64 string
                    btoa() ------ encode to a Base64 string;
// 29-08-2018 ----------------------

                Generating a JWT From Express
                Keeping the secret with environment variables
                    If you'r going to be pishing your code around in varsion control, like GitHub for example, you don't want to have the secret published. Exposing your secret dramaticaly weakens your security model with your secret anybody could issue fake tokens that your application believes to be genuine. To keep secrets a secret, it's often a good idea to set them as environment variables.

    11.3 Creating an authentication API with Passport

        Passport is a Node module by Jared Hanson that's designed to make authentication in Node easy.
        One of its key strengths is that it can accommodete several different methods of authentication, called "strategies". Example of these strategies include 
        Facebook
        Twitter
        OAuth
        Local username and password

        11.3.1 Installing and configuring Passport
            Passport is separated out into a core module and separate modules for each of the strategies. So we'll install the core module and the local strategy module via npm, using the following commands in terminal

            npm install password --save
            npm install password-local --save

            Creating a Passport config file
            Configuring a local strategy
                By default a Passport local strategy expects and uses the fields "username" and "password". We have password so that one's okay, but instead of "username" we're using email. Passport allows you to override the username field in the options object as shown in the follwo 

                Passport.use(new LocalStrategy({usernameField: 'email'}, function(username, password, done){}));
        
// 03-09-2018 -----------------------------
            Adding Passport and the config to the application
                To add our passport setting to the application we need to do three things.

                1. Require Passport
                2. Require the strategy config
                3. Initialize Passport
        11.3.2 Creating API endpoints to return JSON Web Tokens
            To enable users to log in and register via our API, we'll need to have two new endpoints.
            
            Adding the authentication route definitions
            Createing the register controller

// 04-09-2018 --------------------------------
            






                    








            

            


